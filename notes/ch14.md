# 第十四章 重载运算与类型转换

## 基本概念

- 重载运算符是具有特殊名字的函数：由关键字`operator`和其后要定义的运算符号共同组成。
- 当一个重载的运算符是成员函数时，`this`绑定到左侧运算对象。成员运算符函数的参数数量比运算对象的数量**少一个**。
- 只能重载大多数的运算符，而不能发明新的运算符号。
- 重载运算符的优先级和结合律跟对应的内置运算符保持一致。
- 调用方式：
  - `data1 + data2;`
  - `operator+(data1, data2);`

- 不应重载：`&&`、`||`、`，`、取地址`&`
- 不可重载：`::`, `.*`, `.`, `? :`

- 是否作为成员函数：
  - 赋值（`=`）、下标（`[]`）、调用（`()`）和成员访问箭头（`->`）运算符必须是成员。
  - 复合赋值运算符一般来说是成员。
  - 改变对象状态的运算符或者和给定类型密切相关的运算符通常是成员，如递增、解引用。
  - 具有对称性的运算符如算术、相等性、关系和位运算符等，通常是非成员函数。

- 当把运算符定义成成员函数时，它的左侧运算对象必须是运算符所属类的一个对象

```cpp
string s = "world";
string t = s + "!";  // 正确
string u = "hi" + s; // 错误
```

## 输入和输出运算符

- 重载输入输出运算符必须是非成员函数

### 重载输出运算符 <<

- 第一个形参通常是一个非常量的`ostream`对象的引用。非常量是因为向流中写入会改变其状态；而引用是因为我们无法复制一个`ostream`对象。
- 第二个形参一般是一个常量的引用，常量为想要打印的类类型
- `operator<<` 一般返回它的 `ostream` 形参

```cpp
ostream &operator<<(ostream &os, const Sales_data &item) {
    os << item.isbn() << " " << item.units_sold << " "
       << item.revenue << " " << item.avg_price();
    return os;
}
```

### 重载输入运算符 >>

- 第一个形参通常是运算符将要读取的流的引用，第二个形参是将要读取到的（非常量）对象的引用。
- 输入运算符必须处理输入可能失败的情况，而输出运算符不需要。

```cpp
ostream &operator>>(ostream &is, Sales_data &item) {
    double price;
    is >> item.bookNo >>item.units_sold >> price;
    if (is) item.revenue = item.units_sold * price; // 输入成功
    else item = Sales_data();                       // 输入失败，赋予默认状态
    return is;
}
```

## 算数和关系运算符

- 通常定义成非成员函数以允许对左侧或右侧的运算对象进行转换
- 如果类同时定义了算数运算符和相关的复合赋值运算符，则通常情况下应该使用复合赋值来实现算数运算符。

```cpp
Sales_data operator+(const Sales_data &lhs, const Sales_data &rhs) {
    Sales_data sum = lhs;
    sum +=rhs;
    return sum;
}
```

### 相等运算符

- 如果定义了 `operator==`，则这个类也应该定义 `operator!=`。
- 相等运算符和不等运算符的一个应该把工作委托给另一个。
- 相等运算符应该具有传递性，即若 `a==b` 和 `b==c` 都为真，`a==c` 也为真。
- 如果某个类在逻辑上有相等性的含义，则该类应该定义`operator==`，这样做可以使用户更容易使用标准库算法来处理这个类。

### 关系运算符

- 如果存在唯一一种逻辑可靠的`<`定义，则应该考虑为这个类定义`<`运算符。如果同时还包含`==`，则当且仅当`<`的定义和`==`产生的结果一致时才定义`<`运算符。

## 赋值运算符

- 重载赋值运算符必须定义为成员函数，复合赋值运算符通常也是如此。这两类运算符都应该返回左侧运算对象的引用。

## 下标运算符

- 下标运算符 `[]` 必须是成员函数
- 一般会定义两个版本：
  1. 返回普通引用
  2. 作用于常量成员，返回常量引用

## 递增和递减运算符（++、--）

- 定义递增和递减运算符的类应该同时定义前置版本和后置版本，建议定义成类的成员。
- 为了和内置版本保持一致
  - 前置运算符应该返回递增或递减后对象的引用。
  - 后置运算符应该返回递增或递减前对象的值，而不是引用。
- 为了区分前置和后置版本的重载，后置版本接受一个无需命名的（不被使用）的 `int` 类型的形参。
  - 以函数调用的方式调用后置版本必须传递一个整形参数 `p.operator++(0);`

```cpp
// 前置版本
StrBlobPtr& StrBlobPtr::operator++() {
    check(curr, "……")；     // 检查递增是否有效
    ++curr;
    return *this;
}

StrBlobPtr& StrBlobPtr::operator--() {
    --curr;
    check(curr, "……")；     // 检查递减是否有效
    return *this;
}

// 后置版本
StrBlobPtr& StrBlobPtr::operator++(int) {
    StrBlobPtr ret = *this; // 记录当前值
    ++*this;                // 向前移动，使用前置版递增检查有效性
    return ret;             // 返回之前记录的状态
}

StrBlobPtr& StrBlobPtr::operator--(int) {
    StrBlobPtr ret = *this;
    --*this;
    return ret;
}
```

## 成员访问运算符

- 箭头运算符（`->`）必须是类的成员。解引用运算符（`*`）通常也是类的成员。
- 重载的箭头运算符必须返回类的指针或者自定义了箭头运算符的某个类的对象。
- 解引用和乘法的区别是一个是一元运算符，一个是二元运算符。

## 函数调用运算符

- 如果类重载了函数调用运算符`()`，则可以像使用函数一样使用该类的对象。这样的类同时也能存储状态，所以与普通函数相比更加灵活。

```cpp
struct absInt {
    int operator()(intval) const {
        return val < 0 ? -val : val;
    }
};

int i = -42;
absInt absObj;
int ui = absObj(i);
```

- 函数调用运算符必须是成员函数。一个类可以定义多个不同版本的调用运算符，相互之间应该在参数数量或类型上有所区别。
- 如果类定义了调用运算符，则该类的对象称作**函数对象**（function object）。

### `lambda`是函数对象

- `lambda`捕获变量：`lambda`产生的类必须为每个值捕获的变量建立对应的数据成员，同时创建构造函数。

### 标准库定义的函数对象

| 算术               | 关系                  | 逻辑                |
| ------------------ | --------------------- | ------------------- |
| `plus<Type>`       | `equal_to<Type>`      | `logical_and<Type>` |
| `minus<Type>`      | `not_equal_to<Type>`  | `logical_or<Type>`  |
| `multiplies<Type>` | `greater<Type>`       | `logical_not<Type>` |
| `divides<Type>`    | `greater_equal<Type>` |                     |
| `modulus<Type>`    | `less<Type>`          |                     |
| `negate<Type>`     | `less_equal<Type>`    |                     |

- 定义在 `functional` 头文件中，可以在算法中使用标准库函数对象。

### 可调用对象与 function

- 可调用对象：函数、函数指针、`lambda`表达式、`bind`创建的对象以及重载了函数调用运算符的类。
- 不同类型的可调用对象可能具有相同的调用形式
- **标准库 function 类型**：

| 操作                            | 解释                                                                                   |
| ------------------------------- | -------------------------------------------------------------------------------------- |
| `function<T> f;`                | `f`是一个用来存储可调用对象的空`function`，这些可调用对象的调用形式应该与类型`T`相同。 |
| `function<T> f(nullptr);`       | 显式地构造一个空`function`                                                             |
| `function<T> f(obj)`            | 在`f`中存储可调用对象`obj`的副本                                                       |
| `f`                             | 将`f`作为条件：当`f`含有一个可调用对象时为真；否则为假。                               |
| `f(args)`                       | 调用`f`中的对象，参数是`args`                                                          |
| 定义为`function<T>`的成员的类型 |                                                                                        |
| `result_type`                   | 该`function`类型的可调用对象返回的类型                                                 |
| `argument_type`                 | 当`T`有一个或两个实参时定义的类型。如果`T`只有一个实参，则`argument_type`              |
| `first_argument_type`           | 第一个实参的类型                                                                       |
| `second_argument_type`          | 第二个实参的类型                                                                       |

- 例如：声明一个`function`类型，它可以表示接受两个`int`，返回一个`int`的可调用对象。`function<int(int, int)>`
- `map<string, function<int(int, int)>`

## 重载、类型转换、运算符

- 转换构造函数和类型转换运算符共同定义了类类型转换，也称作用户定义的类型转换

### 类型转换运算符

- 类型转换运算符是类的一种特殊成员函数，它负责将一个类类型的值转换成其他类型。类型转换函数的一般形式如：`operator type() const;`
- 类型转换函数必须是类的成员函数；它不能声明返回类型，形参列表也必须为空。类型转换函数通常应该是`const`。
- 避免过度使用类型转换函数。
- 为避免隐式转换带来的异常，引入了显式的类型转换运算符（explicit conversion operator）和显式的构造函数，编译器通常不会将一个显式的类型转换运算符用于隐式类型转换

```cpp
class SmallInt {
public:
    explicit operator int() const {return val;}
}

SmallInt si = 3;
si + 3;                    // 错误，需要隐式类型转换
static_cast<int>(si) + 3;  // 正确，显式请求类型转换
```

- 当表达式出现在下列位置时，显式的类型转换将被隐式的执行：
  - `if`、`while`、`do` 语句的条件部分
  - `for` 语句头的条件表达式
  - 逻辑运算符的运算对象
  - 条件运算符的条件表达式

- 向`bool`的类型转换通常用在条件部分，因此`operator bool`一般定义成`explicit`的。

### 避免有二义性的类型转换

- 通常，不要为类定义相同的类型转换，也不要在类中定义两个及以上转换源或转换目标是算术类型的转换。
- 在调用重载函数时，如果需要额外的标准类型转换，则该转换的级别只有当所有可行函数都请求同一个用户定义的类型转换时才有用。如果所需的用户定义的类型转换不止一个，则该调用具有二义性。

### 函数匹配与重载运算符

- 如果`a`是一种类型，则表达式`a sym b`可能是：
  - `a.operatorsym(b);`
  - `operatorsym(a,b);`
- 如果我们对同一个类既提供了转换目标是算术类型的类型转换，也提供了重载的运算符，则将会遇到重载运算符与内置运算符的二义性问题。
