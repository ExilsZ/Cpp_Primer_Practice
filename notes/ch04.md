# 第四章 表达式

## 表达式基础

- C++定义了一元运算符和二元运算符。
- **组合运算符和运算对象**：对于含有多个运算符的复杂表达式，需要理解运算符的优先级、结合律以及运算对象的求值顺序。
- **运算对象转换**：表达式求值过程中运算对象可能发生类型转换，例如小整数类型会被提升（promoted）为较大的整数类型。
- **重载运算符**（overloaded operator）：当运算符作用在类类型的运算对象时，用户可以自行定义其含义。

- **左值（lvalue）和右值（rvalue）**：
    - `C`中原意：左值可以在赋值语句左侧，右值不能。
    - `C++`中：当一个对象被用作**右值**的时候，用的是对象的**值**（内容）；被用做**左值**时，用的是对象的**身份**（在内存中的位置）。
    - 需要右值的地方可以用左值来代替，反之不可。

- **求值顺序**：优先级规定了运算对象的组合方式，但是运算对象的求值顺序不确定。
  - `int i = f1() + f2()`：先计算`f1() + f2()`,再计算`int i = f1() + f2()`。但是`f1`和`f2`的计算**先后不确定**。
  - 若`f1`、`f2`都对同一对象进行了修改，因为执行顺序不确定，产生未定义行为。
  - 四种运算符明确规定先求左侧运算对象的值：`&&`、`||`、`?:`、`,`。
  - **求值顺序与优先级和结合律无关**

> [!tip] 建议：处理复合表达式时
>- 用括号强制使不确定的表达式组合关系符合程序逻辑
>- 若改变了某个运算对象的值，在同一表达式的其他位置不再使用这个运算对象。当改变运算对象的子表达式本身是另外一个子表达式的运算对象时该规则无效，例如`*++iter`。

## 算术运算符

- `+`、`-`、`*`、`/`、`%`
- **溢出**：当计算的结果超出该类型所能表示的范围时就会产生溢出。
- **`bool`类型不应参与计算**
  ```cpp
  bool b  = true;
  bool b2 = -b; // 仍然为 true
  // b 为 true，提升为对应 int=1，-b=-1，b2=-1!=0，所以 b2 仍为 true
  ```
- 取余运算`m%n`若不为 0，结果符号与`m`相同

## 逻辑和关系运算符

- **短路求值**：逻辑与运算符和逻辑或运算符都是先求左侧运算对象的值再求右侧运算对象的值，当且仅当左侧运算对象无法确定表达式的结果时才会计算右侧运算对象的值。

## 赋值运算符

- 赋值运算的**返回结果是它的左侧运算对象**，且是一个**左值**，类型是左侧对象的类型。
- 如果赋值运算的左右侧运算对象类型不同，则右侧运算对象将转换成左侧运算对象的类型。
- 赋值运算符满足**右结合律**，这点和其他二元运算符不一样。 `ival = jval = 0;`等价于`ival = (jval = 0);`
- 赋值运算优先级比较低，用它当条件时应该加括号。
- 复合运算符（`+=`、`-=`……）只求值一次，用普通运算符求值两次。
- 任意复合运算符`op`等价于`a = a op b;`

## 递增递减运算符

- 前置版本`j = ++i`，先加一后赋值
- 后置版本`j = i++`，先赋值后加一

- ==优先使用前置版本==，后置多一步储存原始值。（除非需要变化前的值）

- 混用解引用和递增运算符，`*iter++`等价于`*(iter++)`，后置递增优先级高于解引用
```cpp
auto iter = vi.begin();
while (iter != vi.end() && *iter >= 0)
    cout << *iter++ << endl; // 输出当前值，指针移 1
```

- **简洁是一种美德**，追求简洁能降低程序出错可能性

## 成员访问运算符

- `ptr->mem`等价于`(*ptr).mem`
  - 注意`.`运算符优先级大于`*`，所以记得加括号

## 条件运算符

- 条件运算符（`?:`）允许我们把简单的`if-else`逻辑嵌入到单个表达式中去，按照如下形式：`cond? expr1: expr2`
- 可以嵌套使用，**右结合律**，从右向左顺序组合
```cpp
finalgrade = (grade > 90)   ? "high pass"
              : (grade < 60) ? "fail"
                            : "pass";
// 等价于
finalgrade = (grade > 90) ? "high pass"
                          : ((grade < 60) ? "fail"
                                          : "pass");
```

- 输出表达式使用条件运算符需要加括号，条件运算符优先级非常低。

## 位运算符

- 位运算符作用于**整数类型**的运算对象，用于检查和设置二进制位。
- 二进制位向左移（`<<`）或者向右移（`>>`），移出边界外的位就被舍弃掉了。
- 位取反（`~`）、位与（`&`）、位或（`|`）、位异或（`^`）
- 移位运算符（IO 运算符）满足左结合律，优先级比算术运算符优先级低，比关系、赋值、条件运算符的优先级高，使用时注意适当加括号。

- 有符号数负值左移操作可能变号，所以强烈**建议位运算符仅用于无符号数**。

- 应用：
  ```cpp
  unsigned long quiz1 = 0;    // 每一位代表一个学生是否通过考试
  1UL << 12;  // 代表第 12 个学生通过
  quiz1 |= (1UL << 12);   // 将第 12 个学生置为已通过
  quiz1 &= ~(1UL << 12);  // 将第 12 个学生修改为未通过
  bool stu12 = quiz1 & (1UL << 12);   // 判断第 12 个学生是否通过
  ```

## sizeof 运算符

- 两种形式：
    1. `sizeof (type)`，给出类型名
    2. `sizeof expr`，给出表达式

- 返回一条表达式或一个类型名字所占的**字节数**。
- 返回`size_t`类型的常量表达式。
- `sizeof`并不实际计算其运算对象的值，即使对无效指针`p`做`sizeof(*p)`也是安全行为
- 满足右结合律，从右向左组合
- 可用`sizeof`返回数组的大小
- 使用作用域运算符获取类成员的大小，不需要提供具体对象
- 对`string`对象或`vector`对象执行`sizeof`运算只返回该类型固定部分的大小，不会计算对象中的元素占用的空间

```cpp
int ia[10];
// sizeof(ia) 返回整个数组所占空间的大小
// sizeof(ia)/sizeof(*ia) 返回数组的大小
constexpr size_t sz = sizeof(ia)/sizeof(*ia);
int arr[sz];
```

## 逗号运算符

- 从左向右依次求值，左侧求值结果丢弃，逗号运算符**结果是右侧表达式**的值。

## 类型转换
s
###   隐式转换（implicit conversion）
- 比`int`类型小的整数值先提升为较大的整数类型。
- 条件中，非布尔转换成布尔。
- 初始化中，初始值转换成变量的类型。赋值语句中右侧运算对象转换成左侧运算对象的类型。
- 算术运算或者关系运算的运算对象有多种类型，要转换成同一种类型。
- 函数调用时也会有类型转换。
- 数组转换成指针
- 指针的转换
- 转换成布尔类型
- 转换成常量
- 类类型定义的转换

### 算术转换
- 设计上算术类型间的隐式转换会尽可能避免损失精度

- 整型提升负责将小整数类型转换成较大的整数类型
  - 常见的`char`、`bool`、`short`能存到`int`就会转换成`int`，否则提升为`unsigned int`
  - `wchar_t`、`char16_t`、`char32_t`提升为整型中`int`、`unsigned int`、`long`、`unsigned long`……中最小的且能容纳原类型所有可能值的类型。

### 显式类型转换
- 命名的强制类型转换：`cast-name<type>(expression)`
  - **static_cast**：任何明确定义的类型转换，只要不包含底层`const`，都可以使用。 `double slope = static_cast<double>(j);`
  - **dynamic_cast**：支持运行时类型识别。
  - **const_cast**：只能改变运算对象的底层`const`，将常量对象转换成非常量对象，可用于去除`const`性质。
    - `const char *pc; char *p = const_cast<char*>(pc)`。对常量对象使用`const_cast`执行写操作是未定义行为。
  - **reinterpret_cast**：通常为运算对象的位模式提供低层次上的重新解释。

- 旧式强制类型转换：
  - `type (expr)`：函数形式的强制类型转换
  - `(type) (expr)`：C 风格的强制类型转换

### 运算符优先级表
略
