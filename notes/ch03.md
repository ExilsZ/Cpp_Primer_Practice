# 第三章 字符串、向量和数组

## 命名空间的 using 声明

- 使用某个命名空间：例如`using std::cin;`表示使用命名空间`std`中的名字`cin`。
- 头文件中不应包含`using`声明，否则使用了该头文件的源码也会使用这个声明，会带来风险。

## 标准库类型 string

- 标准库类型`string`表示可变长的字符序列。
```cpp
#include <string>
using std::string;
```

### 定义和初始化 string 对象
| 方式                  | 解释                                                    |
| --------------------- | ------------------------------------------------------- |
| `string s1`           | 默认初始化，`s1`是个空字符串                            |
| `string s2(s1)`       | `s2`是`s1`的副本                                        |
| `string s2 = s1`      | 等价于`s2(s1)`，`s2`是`s1`的副本                        |
| `string s3("value")`  | `s3`是字面值“value”的副本，除了字面值最后的那个空字符外 |
| `string s3 = "value"` | 等价于`s3("value")`，`s3`是字面值"value"的副本          |
| `string s4(n, 'c')`   | 把`s4`初始化为由连续`n`个字符`c`组成的串                |

- **拷贝初始化**（copy initialization）：使用等号`=`将一个已有的对象拷贝到正在创建的对象。
- **直接初始化**（direct initialization）：通过括号给对象赋值。

### string 对象上的操作
| 操作              | 解释                                                                 |
| ----------------- | -------------------------------------------------------------------- |
| `os << s`         | 将`s`写到输出流`os`当中，返回`os`                                    |
| `is >> s`         | 从`is`中读取字符串赋给`s`，字符串以空白分割，返回`is`                |
| `getline(is, s)`  | 从`is`中读取一行赋给`s`，返回`is`                                    |
| `s.empty()`       | `s`为空返回`true`，否则返回`false`                                   |
| `s.size()`        | 返回`s`中字符的个数                                                  |
| `s[n]`            | 返回`s`中第`n`个字符的引用，位置`n`从 0 计起                         |
| `s1+s2`           | 返回`s1`和`s2`连接后的结果                                           |
| `s1=s2`           | 用`s2`的副本代替`s1`中原来的字符                                     |
| `s1==s2`          | 如果`s1`和`s2`中所含的字符完全一样，则相等；对字母大小写敏感         |
| `s1!=s2`          | 同上                                                                 |
| `<`,`<=`,`>`,`>=` | 利用字符在字典中的顺序对第一个不相同的字符进行比较，对字母大小写敏感 |

- 读写`string`对象：
  - 执行读操作`>>`：自动忽略开头的空白（包括空格、换行符和制表符），从第一个字符开始，直到遇到空白为止。
  - 使用循环读取未知数量的`string`对象
  - `getline`：读取一整行，**包括空白符**，到换行符为止（读取换行符但不保存）。

- `s.size()`返回的是`string::size_type`类型，是**无符号整型**的值，不要和`int`在表达式中混用
- `s1+s2`使用时，保证至少一侧是`string`类型。
  - `string s1 = "hello" + "world" // 错误，两侧均为字符串字面值`
- **字符串字面值和`string`是不同的类型。**

### 处理 string 对象中的字符
`C++`标准库兼容`C`语言的标准库，如`C++`版本为`cctype`，`C`版本为`ctype.h`。**建议使用`C++`版本的头文件，即`cctype`**。
`cctype`头文件中定义了一组标准函数：

| 函数          | 解释                                                               |
| ------------- | ------------------------------------------------------------------ |
| `isalnum(c)`  | 当`c`是字母或数字时为真                                            |
| `isalpha(c)`  | 当`c`是字母时为真                                                  |
| `iscntrl(c)`  | 当`c`是控制字符时为真                                              |
| `isdigit(c)`  | 当`c`是数字时为真                                                  |
| `isgraph(c)`  | 当`c`不是空格但可以打印时为真                                      |
| `islower(c)`  | 当`c`是小写字母时为真                                              |
| `isprint(c)`  | 当`c`是可打印字符时为真                                            |
| `ispunct(c)`  | 当`c`是标点符号时为真                                              |
| `isspace(c)`  | 当`c`是空白时为真（空格、横向/纵向制表符、回车符、换行符、进纸符） |
| `isupper(c)`  | 当`c`是大写字母时为真                                              |
| `isxdigit(c)` | 当`c`是十六进制数字时为真                                          |
| `tolower(c)`  | 当`c`是大写字母，输出对应的小写字母；否则原样输出`c`               |
| `toupper(c)`  | 当`c`是小写字母，输出对应的大写字母；否则原样输出`c`               |

- 遍历字符串：使用**范围 for**（range for）语句：`for (auto c: str)`，或者`for (auto &c: str)`使用引用可直接改变字符串中的字符。
- `str[x]`，下标的值称作下标或索引，只要值为整型将自动转换成`string::size_type`类型（**无符号**类型）。

> [!warning]
> - 范围 for 语句体内不应改变其所遍历序列的大小。
> - 不能用下标形式添加元素
> - `C++`标准不要求标准库检测下标是否合法，注意检查下标的合法性。

## 标准库类型 vector

```cpp
#include <vector>
using std::vector;
```
- `vector`也被称作**容器**（container），是一个类模板；
- 类模板：本身不是类，但可以**实例化**（instantiation）出一个类。`vector`是模板，`vector<int>`是类型。
- 通过将类型放在类模板名称后面的**尖括号**中来指定**类型**，如`vector<int> ivec`。

### 定义和初始化 vector 对象
| 方法                        | 解释                                                    |
| --------------------------- | ------------------------------------------------------- |
| `vector<T> v1`              | `v1`是一个空`vector`，潜在元素是`T`类型，执行默认初始化 |
| `vector<T> v2(v1)`          | `v2`中包含有`v1`所有元素的副本                          |
| `vector<T> v2 = v1`         | 等价于`v2(v1)`，`v2`中包含`v1`所有元素的副本            |
| `vector<T> v3(n, val)`      | `v3`包含了 n 个重复的元素，每个元素的值都是`val`        |
| `vector<T> v4(n)`           | `v4`包含了 n 个重复地执行了值初始化的对象               |
| `vector<T> v5{a, b, c...}`  | `v5`包含了初始值个数的元素，每个元素被赋予相应的初始值  |
| `vector<T> v5={a, b, c...}` | 等价于`v5{a, b, c...}`                                  |

```cpp
#include <vector>
using std::vector;

vector<int> v1(10);
vector<string> v2(10);
vector<string> v3{"a", "an", "the"};
```

### 向 vector 对象中添加元素
- `v.push_back(e)`在尾部增加元素。
- 不必要在定义`vector`对象时设定其大小，推荐创建空的`vector`对象，运行时动态添加元素。

### 其他 vector 操作
| 操作              | 解释                                                         |
| ----------------- | ------------------------------------------------------------ |
| `v.emtpy()`       | 如果`v`不含有任何元素，返回真；否则返回假                    |
| `v.size()`        | 返回`v`中元素的个数                                          |
| `v.push_back(t)`  | 向`v`的尾端添加一个值为`t`的元素                             |
| `v[n]`            | 返回`v`中第`n`个位置上元素的**引用**                         |
| `v1 = v2`         | 用`v2`中的元素拷贝替换`v1`中的元素                           |
| `v1 = {a,b,c...}` | 用列表中元素的拷贝替换`v1`中的元素                           |
| `v1 == v2`        | 当且仅当元素数量相同且对应位置的元素值都相同时`v1`和`v2`相等 |
| `v1 != v2`        | 同上                                                         |
| `<`,`<=`,`>`,`>=` | 以字典顺序进行比较                                           |

- 范围`for`语句内不应该改变其遍历序列的大小。
- `vector`对象（以及`string`对象）的下标运算符，只能对确知已存在的元素执行下标操作，不能用于添加元素。

## 迭代器介绍

- 所有标准库容器都可以使用迭代器（iterator），只有少数几种同时支持下标运算符。
- 类似于指针类型，迭代器也提供了对对象的间接访问。

### 使用迭代器
- **容器**：可以包含其他对象，但所有的对象必须类型相同。
- **迭代器（iterator）**：每种标准容器都有自己的迭代器。`C++`倾向于用迭代器而不是下标遍历元素。
```cpp
vector<int>::iterator iter;
auto b = v.begin(); // 返回指向第一个元素的迭代器

auto e = v.end();
// 返回指向尾元素的 下一个位置 的迭代器
// 称为尾后迭代器（off-the-end iterator）或尾迭代器（end iterator）
```
- `v.begin() - v.end() <= 0`
- 如果容器为空，`begin()`和`end()`返回的是同一个迭代器，都是尾后迭代器。
- 使用解引用符`*`访问迭代器指向的元素。
- 所有标准库容器的迭代器都定义了`==`和`!=`，但大多数都没有定义`<`，推荐养成使用迭代器和`!=`的习惯（泛型编程）。

- **const_iterator**：只能读取不能改变容器内元素。
- `cbegin()`、`cend()`：不论`vector`对象本身是否是常量，返回值都是`const_iterator`

- **谨记**：但凡是使用了**迭代器**的循环体，都**不要**向迭代器所属的容器**添加元素**。

标准容器迭代器的运算符：

| 运算符           | 解释                                          |
| ---------------- | --------------------------------------------- |
| `*iter`          | 返回迭代器`iter`所指向的元素的**引用**        |
| `iter->mem`      | 等价于`(*iter).mem`                           |
| `++iter`         | 令`iter`指示容器中的下一个元素                |
| `--iter`         | 令`iter`指示容器中的上一个元素                |
| `iter1 == iter2` | 判断两个迭代器是否相等                        |
| `iter1 != iter2` | 判断两个迭代器是否相等                        |
| `->`             | 解引用 + 成员访问，`it->mem`等价于`(*it).mem` |

### 迭代器运算
- `vector`和`string`迭代器支持的运算（n 为整数）：

| 运算符               | 解释                                                                                   |
| -------------------- | -------------------------------------------------------------------------------------- |
| `iter + n`           | 仍得到一个迭代器，指示向后移动了若干个元素。指示容器内的一个元素，或尾元素的下一位置   |
| `iter - n`           | 仍得到一个迭代器，指示向前移动了若干个元素。指示容器内的一个元素，或尾元素的下一位置   |
| `iter1 += n`         | 迭代器加法的复合赋值语句，将`iter1`加`n`的结果赋给`iter1`                              |
| `iter1 -= n`         | 迭代器减法的复合赋值语句，将`iter2`减`n`的加过赋给`iter1`                              |
| `iter1 - iter2`      | 得到两个迭代器之间的距离，参与运算的两个迭代器必须指向同一个容器中的元素或者是尾迭代器 |
| `>`、`>=`、`<`、`<=` | 迭代器的关系运算符                                                                     |

- 迭代器相减运算的结果是`difference_type`类型的带符号整型数，可正可负。

## 数组（不推荐使用）

- 类似于`vector`，**长度固定**。
- `Do not declare C-style arrays, use std::array<> instead`

### 定义和初始化内置数组
- 初始化：`char input_buffer[buffer_size];`，长度必须是 const 表达式，或者不写，让编译器自己推断。
- 数组不允许直接赋值给另一个数组。

### 访问数组元素
- 数组下标的类型：`size_t` 。
- 字符数组的特殊性：结尾处有一个空字符，如`char a[] = "hello";` 。
- 用数组初始化`vector`：`int a[] = {1,2,3,4,5}; vector<int> v(begin(a), end(a));` 。

### 数组和指针
- 使用数组时，编译器一般会把它转换成指针。
- 标准库类型限定使用的下标必须是无符号类型，而内置的下标可以处理负值。
- **指针访问数组**：在表达式中使用数组名时，名字会自动转换成指向数组的第一个元素的指针。

### C 风格字符串（不推荐）
- 从`C`继承来的字符串。
- 用空字符结束（`\0`）。
- 对大多数应用来说，使用标准库`string`比使用`C`风格字符串更安全、更高效。
- 获取`string`中的`cstring` ：`const char *str = s.c_str();` 。

`C`标准库 String 函数，定义在`<cstring>` 中：

| 函数             | 介绍                                                |
| ---------------- | --------------------------------------------------- |
| `strlen(p)`      | 返回`p`的长度，空字符不计算在内                     |
| `strcmp(p1, p2)` | 比较`p1`和`p2`的相等性。如果`p1>p2`，返回一个正值； |
| `strcat(p1, p2)` | 将`p2`附加到`p1`之后，返回`p1`                      |
| `strcpy(p1, p2)` | 将`p2`拷贝给`p1`，返回`p1`                          |

 - **尽量使用 `vector` 和迭代器，少用数组**

## 多维数组

- **多维数组的初始化**：`int ia[3][4] = {{0,1,2,3}, ...}`。
- 使用范围`for`语句时，除了最内层的循环外，其他所有循环的控制变量都应该是**引用**类型。

## 指针 vs 引用

- 引用总是指向某个对象，定义引用时没有初始化是错的。
- 给引用赋值，修改的是该引用所关联的对象的值，而不是让引用和另一个对象相关联。

## 指向指针的指针

- 定义：`int **ppi = &pi;`
- 解引用：`**ppi`

## 动态数组

- 使用`new`和`delete`实现和`C`中`malloc`和`free`类似的功能，即在堆（自由存储区）中分配存储空间。
  - 申请空间：`int *pia = new int[10];`。
  - 释放空间：`delete[] pia;`，注意不要忘记`[]`。
