# 第六章 函数

## 函数基础

- **函数**定义：包括返回类型、函数名字、由 0 个或者多个**形参**（parameter）组成的列表和函数体。
- **调用运算符**：调用运算符的形式是一对圆括号`()`，作用于一个表达式，该表达式是函数或者指向函数的指针。
  - 圆括号内是用逗号隔开的**实参**（argument）列表。
- 函数调用：
  1. 用实参初始化函数的形参
  2. 控制权转移给被调用函数
    1. 主调函数（calling function）的执行被暂时中断。
    2. 被调函数（called function）开始执行。
- **形参和实参**：实参是形参的初始值，形参和实参的**个数**和**类型**必须匹配上。
- **返回类型**： `void`表示函数不返回任何值。函数的返回类型不能是数组类型或者函数类型，但可以是指向数组或者函数的指针（或引用）。

### 局部对象
- 名字有作用域，对象有生命周期：
  - **名字**：名字的作用域是程序文本的一部分，名字在其中可见。
  - **生命周期**：对象的生命周期是程序执行过程中该对象存在的一段时间。

- **局部变量（local variable）**：形参和函数体内部定义的变量统称为局部变量。它对函数而言是局部的，对函数外部而言是**隐藏**的。
- **自动对象（automatic object）**：只存在于块执行期间的对象，当块的执行结束后，它的值就变成**未定义**。
  - 形参是一种自动对象
- **局部静态对象（local static object）**：`static`类型的局部变量
  - 局部静态对象在程序第一次执行到定义语句时初始化，直到程序终止才销毁
  - 若没有显式初始值将执行值初始化。

### 函数声明
- 函数只能定义一次，可以声明多次。
- 不被使用的函数可以只有声明没有定义。
- 函数的声明和定义唯一的区别是声明无需函数体，用一个分号替代，因此无须形参名字。

- 函数的三要素（返回类型、函数名、形参类型）描述了函数的接口，说明了调用函数所需的全部信息。
- 函数声明也称作**函数原型（function prototype）**。
- **在头文件中进行函数声明**：建议变量和函数在头文件中声明，在源文件中定义。

- **分离式编译（separate compilation）**：将程序分割到多个文件中，每个文件独立编译，链接形成可执行文件。

## 参数传递

- 形参初始化的机理和变量初始化一样。
- **引用传递（passed by reference）**：又称传引用调用（called by reference），指**形参是引用类型**，引用形参是它对应的实参的别名。
- **值传递（passed by value）**：又称传值调用（called by value），指实参的值是通过**拷贝**传递给形参。

### 传值参数
- 初始化非引用类型的形参时，拷贝初始值给形参，函数对形参做的所有操作都不会影响实参。
- 指针形参拷贝指针的值，常用在`C`中，`C++`建议使用引用类型的形参代替指针。

### 传引用参数
- 通过使用引用形参，允许函数改变实参的值。
- 经常用引用形参来**避免复制**以及**返回额外的信息**。
  ```cpp
  void swap(int &v1, int &v2);
  ```
- ==如果无需改变引用形参的值，最好将其声明为常量引用==。

### const 形参和实参
- 用实参初始化形参时会忽略顶层`const`。
  - `void func(const int i);`调用时既可以传入`const int`也可以传入`int`。
- 形参初始化方式和变量的初始化方式一样
  - 可以使用非常量初始化一个底层`const`对象，但是反过来不行。
  - 一个普通的引用必须用同类型的对象初始化。
  ```cpp
  int i = 42;
  const int *cp = &i; //正确
  const int &r = i; //正确
  const int &r2 = 42; //正确
  int *p = cp; //错误
  int &r3 = r; //错误
  int &r4 = 42; //错误
  ```

- C++允许用字面值初始化常量引用。
- 尽量使用常量引用。

### 数组形参
- 当我们为函数传递一个数组时，实际上传递的是指向数组首元素的指针。
- 要注意数组的实际长度，不能越界
  - 传递指向数组首尾元素的指针
  - 显式传递表示数组大小的形参

### main 处理命令行选项
- `int main(int argc, char *argv[]) {...}`
- 第一个形参代表参数的个数；第二个形参是参数`C`风格字符串数组。
- 使用`argv`中的实参时，可选的实参从`argv[1]`开始，`argv[0]`保存程序的名字

### 含有可变形参的函数
- 无法预知应该向函数传递几个实参：
  - 若所有实参类型相同，可以传递`initializer_list`的标准库类型
  - 若实参类型不同，可以编写一种特殊的函数，即所谓的可变参数模板

- 省略形参符：`...`，便于`C++`访问某些`C`代码，这些`C`代码使用了`varargs`的`C`标准库功能。

- `initializer_list`提供的操作（`C++11`）：

| 操作                               | 解释                                                   |
| ---------------------------------- | ------------------------------------------------------ |
| `initializer_list<T> lst;`         | 默认初始化；`T`类型元素的空列表                        |
| `initializer_list<T> lst{a,b...};` | `lst`的元素是对应初始值的副本；列表中的元素是`const`。 |
| `lst2(lst)`                        | 拷贝或赋值一个`initializer_list`对象                   |
| `lst2 = lst`                       | 同上                                                   |
| `lst.size()`                       | 列表中的元素数量                                       |
| `lst.begin()`                      | 返回指向`lst`中首元素的指针                            |
| `lst.end()`                        | 返回指向`lst`中微元素下一位置的指针                    |

- `initializer_list`使用：
  ```cpp
  void err_msg(ErrCode e, initializer_list<string> il) {
      for (auto bed = il.begin(); beg != il.end(); ++ beg)
          cout << *beg << " ";
      cout << endl;
  }

  err_msg(ErrCode(0), {"functionX", "okay});
  ```

## 返回类型和 return 语句

### 无返回值函数
没有返回值的`return`语句只能用在返回类型是`void`的函数中，返回`void`的函数不要求有`return`语句。

### 有返回值函数
- `return`语句的返回值的类型必须和函数的返回类型相同，或者能够**隐式地**转换成函数的返回类型。
- 返回的值用于初始化调用点的一个**临时量**，该临时量就是函数调用的结果。
- **不要返回局部对象的引用或指针**。
- **引用返回左值**：函数的返回类型决定函数调用是否是左值。
  - 调用一个返回引用的函数得到左值，其他返回类型得到右值。
- **列表初始化返回值**：函数可以返回花括号包围的值的列表。（`C++11`）
- **主函数`main`的返回值**：如果结尾没有`return`，编译器将隐式地插入一条返回 0 的`return`语句，返回 0 代表执行成功。

### 返回数组指针
```cpp
  int arr[10];  // arr 是一个含有 10 个整数的数组
  int* p1[10];  // p1 是一个含有 10 个指针的数组
  int(*p2)[10]; // p2 是一个指针，他指向含有 10 个整数的数组
```

- 声明一个返回数组指针的函数：`Type (*function(parameter_list)) [dimension]`
  ```cpp
  int (*func(int i)) [10];
  ```

- 使用类型别名：`typedef int arrT[10];`或者`using arrT = int[10]`，然后`arrT* func() {...}`

- **尾置返回类型**：在形参列表后面以一个`->`开始
```cpp
// func 接受一个 int 实参，返回一个指针，该指针指向含有 10 个整数的数组
auto func(int i) -> int(*)[10]
```

- 使用`decltype`： `decltype(odd) *arrPtr(int i) {...}`

## 函数重载

- **重载**：如果同一作用域内几个函数名字相同但形参列表不同，称之为**重载**（overload）函数。
  - `main`函数不能重载。

- **重载和`const`形参**：
  - 重载无法区分有顶层`const`形参和无顶层`const`形参
    - `Record lookup(Phone) {};`和`Record lookup(const Phone) {};`无法区分。
  - 可以区分是否有底层`const`的形参。
    - `Record lookup(Account*) {};`和`Record lookup(const Account*) {};`可以区分。

- **重载和作用域**：若在内层作用域中声明名字，它将隐藏外层作用域中声明的同名实体，在不同的作用域中无法重载函数名

## 特殊用途语言特性

### 默认实参
```cpp
sz wd = 80;
char def = ' ';
sz ht();
string screen(sz = ht(), sz = wd, char backgrnd = def);
```
- 在给定作用域中一个形参只能被赋予一次默认实参，且该形参右侧的所有形参都必须有默认值
- 局部变量不能作为默认实参
- 用作默认实参的名字在函数声明所在的作用域内解析，而名字的求值过程发生在函数调用时

### 内联（inline）函数
- 普通函数的缺点：调用函数比求解等价表达式要慢得多。
- `inline`函数可以避免函数调用的开销，可以让编译器在编译时**内联展开**该函数，编译器可以选择忽略

### constexpr 函数
- 指能用于常量表达式的函数
  - `constexpr int new_sz() {return 42;}`
- 函数的返回类型及所有形参类型都要是字面值类型
- 函数体中必须有且只有一条`return`语句
- 隐式地指定为内联函数
- 可以在程序中多次定义，通常定义在头文件中

- 内联函数和`constexpr`可以在程序中多次定义，通常定义在头文件中

### 调试帮助 #TODO
- `assert`预处理宏（preprocessor macro），常用于检查不能发生的条件
  - `assert(expr);`
  - `assert(word.size() > threshold)`

- `NDEBUG`预处理变量，开关调试状态
  - 定义了`NDEBUG`则`assert`会什么也不做
  - `CC -D NDEBUG main.c`可以定义这个变量`NDEBUG`，等价于在 main.c 文件的一开始写`#define NDEBUG`

```cpp
void print(){
    #ifndef NDEBUG
        cerr << __func__ << "..." << endl;
    #endif
}
```

## 函数匹配

- 重载函数匹配的**三个步骤**：1.候选函数；2.可行函数；3.寻找最佳匹配。
  - **候选函数**：选定本次调用对应的重载函数集，集合中的函数称为候选函数（candidate function）。
  - **可行函数**：考察本次调用提供的实参，选出可以被这组实参调用的函数，新选出的函数称为可行函数（viable function）。
  - **寻找最佳匹配**：基本思想：实参类型和形参类型越接近，它们匹配地越好。

## 函数指针

- **函数指针**：是指向函数的指针。
  - `bool (*pf)(const string &, const string &);` 注：pf 两端的括号不可少。

### 使用函数指针
- 把函数名作为一个值使用时，该函数自动地转换成指针
  - `pf = lengthCompare;`
  - `pf = &lengthCompare;`
- 直接使用指向函数的指针调用该函数，无须提前解引用
  - `bool b1 = pf("hello", "goodbye")`
  - `bool b2 = (*pf)("hello", "goodbye")`
  - `bool b3 = lengthCompare("hello", "goodbye")`

### 重载函数的指针
- 定义指向重载函数的指针，指针类型必须与重载函数中的某一个精确匹配

### 函数指针形参：
- 形参是指向函数的指针
  - 形参中使用函数定义或者函数指针定义效果一样。
  - 使用类型别名或者`decltype`。

### 返回指向函数的指针
- 将返回类型写成指向函数类型的指针形式
  - 类型别名
  - 直接声明
  - 尾置返回类型
    - `auto f1(int) -> int (*)(int*, int);`
