# 第二章 变量和基本类型

- 任何常用的编程语言都具备一组公共的语法特征，最基本的特征包括：
  - 整型、字符型等内置类型
  - 变量，用来为对象命名
  - 表达式和语句，用于操作上述数据类型的具体值
  - `if`或`while`等控制结构，有选择地执行一些语句或重复地执行一些语句
  - 函数，用于定义可供随时调用的计算单元

- 大多数编程语言通过两种方式来进一步补充其基本特征：
  - 自定义数据类型，实现对语言的扩展
  - 将一些有用的功能封装成库函数

- `C++`中程序员通过“类类型（class type）”自定义数据类型，允许新类型中既包含数据成员也包含函数成员。

- 一些语言如`Python`，在程序运行时检查数据类型；`C++`是静态数据类型语言，在编译时进行类型检查。

## 基本内置类型

- 基本数据类型包括**算术类型**（arithmetic type）和**空类型**（void）。函数不返回任何值时使用空类型作为返回类型。

### 算术类型

- 算术类型分为两类：整型和浮点型。算术类型的尺寸在不同机器上有所差别，下表为 C++标准规定的尺寸的最小值

| 类型          | 含义           | 最小尺寸                         |
| ------------- | -------------- | -------------------------------- |
| `bool`        | 布尔类型       | 8bits                            |
| `char`        | 字符           | 8bits                            |
| `wchar_t`     | 宽字符         | 16bits                           |
| `char16_t`    | Unicode 字符   | 16bits                           |
| `char32_t`    | Unicode 字符   | 32bits                           |
| `short`       | 短整型         | 16bits                           |
| `int`         | 整型           | 16bits (在 32 位机器中是 32bits) |
| `long`        | 长整型         | 32bits                           |
| `long long`   | 长整型         | 64bits（C++11）                  |
| `float`       | 单精度浮点数   | 6 位有效数字                     |
| `double`      | 双精度浮点数   | 10 位有效数字                    |
| `long double` | 扩展精度浮点数 | 10 位有效数字                    |

- 除布尔型和扩展字符型，其他整型可分为带符号（signed）和无符号（unsigned）两种。

- 如何选择类型：
  - 当明确知晓数值不可能是负数时，选用无符号类型；
  - 使用`int`执行整数运算。一般`long`的大小和`int`一样，而`short`常常显得太小。除非超过了`int`的范围，选择`long long`。
  - 算术表达式中不要使用`char`或`bool`，因为`char`在不同机器上可能有符号可能无符号。
  - 浮点运算选用`double`。

### 类型转换

- 类型所能表示的值的范围决定了转换过程：
  - 非布尔型赋给布尔型，初始值为 0 则结果为`false`，否则为`true`。
  - 布尔型赋给非布尔型，初始值为`false` 结果为 0，初始值为`true`结果为 1。
  - 浮点类型和整数类型之间赋值可能出现精度丢失。
  - 赋给带符号类型一个超出表示范围的值时，结果是未定义的（undefined）。
  - **切勿混用带符号类型和无符号类型**

### 字面值常量

- 一个形如`42`的值被称作**字面值常量（literal）**。

- 整型和浮点型字面值
- 字符和字符串字面值（C 语言风格）
  - 字符字面值：单引号括起，`'a'`
  - 字符串字面值：双引号括起，`"Hello World"`
  - 分多行书写字符串。
    ```cpp

std:cout<<"wow, a really, really long string"
          "literal that spans two lines" <<std::endl;
    ```

- 转义序列：`\n`、`\t`等。
- 布尔字面值：`true`，`false`。
- 指针字面值：`nullptr`

- 字符串型实际上是常量字符构成的数组，结尾处以`'\0'`结束，所以字符串类型实际长度比内容多 1。

## 变量

- **变量**提供一个**具名**的、可供程序操作的存储空间。`C++`中**变量**和**对象**一般可以互换使用。

### 变量定义（define）

- **定义形式**：**类型说明符（type specifier）** + 一个或多个变量名组成的列表。
  - 如 `int sum = 0, value, units_sold = 0;`

- **初始化（initialize）**：对象在创建时获得了一个特定的值。
  - **列表初始化（list initialization）**：使用花括号`{}`，如`int units_sold{0};`
  - 默认初始化（default initialized）：定义时没有指定初始值会被默认初始化；**在函数体内部的内置类型变量不会被初始化**。
  - 未初始化的变量含有一个不确定的值，建议初始化每一个内置类型的变量。

- 在 C++中**初始化不是赋值**：
  - 初始化 = 创建变量 + 赋予初始值
  - 赋值 = 擦除对象的当前值 + 用新值代替

### 变量声明和定义的关系

- 为了支持**分离式编译（separate compliation）**，`C++`将声明（declaration）和定义（define）区分开。**声明**使得名字为程序所知。**定义**负责创建与名字关联的实体。

- 只声明而不定义：在变量名前添加关键字`extern`，如`extern int i;`。但如果包含了初始值，即显式初始化，就变成了定义：`extern double pi = 3.14;`
- 变量只能被定义一次，但是可以被多次声明。定义只出现在一个文件中，其他文件使用该变量时需要对其声明。

### 标识符

- `C++` 的标识符（identifier）由字母、数字和下划线组成，必须以字母或下划线开头，长度没有限制，对大小写字母敏感。
  - C++关键字不能用作标识符。
  - 不推荐使用下划线开头的命名，因为标准库中的命名均为双下划线开头或者下划线 + 大写字母的方式开头。

- 变量命名规范：
  - 需体现实际意义
  - 变量名一般用小写字母，如 index
  - 自定义类名一般用大写字母开头，如 Sales_item
  - 若标识符由多个单词组成，中间须有明显区分：student_loan 或 studentLoan，不要用 studentloan。

- C++操作符替代名：
  - `and`、`bitand`、`compl`、`not_eq`、`or_eq`、`xor_eq`、`and_eq`、`bitor`、`not`、`or`、`xor`

### 名字的作用域 #TODO

- 作用域（scope）多以花括号 `{}` 分隔，名字声明的位置决定作用域的范围：全局作用域、块作用域。

- **第一次使用变量时再定义它**。
- 嵌套的作用域：
  - 内层作用域和外层作用域存在同名变量时，外层的名字会被隐藏起来
  - 存在同名的全局变量和局部变量时，在已定义局部变量的作用域中可用`::name`显式访问全局变量`name`。
- **用到全局变量时，尽量不定义同名的局部变量**。

## 复合类型

### 左值和右值

- **左值**（l-value）**可以**出现在赋值语句的左边或者右边，比如变量；
- **右值**（r-value）**只能**出现在赋值语句的右边，比如常量。

### 引用

- **引用**：引用（reference）是为一个**对象**所起的**别名**，引用类型引用另外一种类型。如`int &refVal = val;`。
- 定义引用时，将引用和它的初始值**绑定**（bind）在一起，**不是拷贝**。一旦初始化完成就不能更改绑定为其他的对象，因此引用必须初始化。
- 引用本身不是一个对象，不能定义引用的引用。

### 指针

```cpp
int *p;      // 指向 int 型对象的指针
```

- 指针是一种**指向**（point to）另外一种类型的复合类型，存放某个对象的**地址**。
- **定义**指针类型：`int *p;`
  - **从右向左读有助于阅读**，`p` 是指向 `int` 类型的指针。

- 获取对象的地址：`int i=42; int *p = &i;`。`&`是**取地址符**。
- 指针的类型与所指向的对象类型必须一致（均为同一类型 int、double 等）

- 指针的值（即地址）的四种状态：
  - 指向一个对象；
  - 指向紧邻对象所占空间的下一个位置；
  - 空指针（`nullptr`），不指向任何对象：；
  - 无效指针。

- 利用指针访问对象：`cout << *p;`输出`p`指针所指对象的数据，`*`是**解引用符**。

- 赋值和指针：
  - 指针和引用的区别：引用本身并非一个对象，引用定义后不能绑定到其他对象；指针没有此限制，和变量一样使用。
  - 赋值语句永远改变的是**左侧**的对象。
  - `void*`指针可以存放**任意类型**对象的地址。因无类型，仅操作内存空间，无法访问所存对象。其他指针类型必须要与所指对象**严格匹配**。
  - 两个指针相减的类型是`ptrdiff_t`。
  - 建议：**初始化所有指针**。

### 理解复合类型的声明

- 定义多个变量：
  - `int i, *p = &i, &r = i;`
  - `int* p1, p2;` 中 p1 是指针，p2 是 `int` 型

- 指向指针的指针

  ```cpp {.line-numbers}
  int ival = 1024;
  int *pi = &ival;
  int **ppi = &pi;
  ```

- 指向指针的引用

  ```cpp {.line-numbers}
  int i = 1024;
  int* p;
  int*& r = p;  // r 是对指针 p 的引用
  r       = &i; // 给 r 赋值&i 就是令 p 指向 i
  *r      = 0;  // 解引用 r 得到 i，也就是 p 指向的对象，将 i 的值改为 0
  ```

- 面对复杂的指针或引用的声明时，从右向左阅读有助于理解

## const 限定符

- 动机：希望定义一些值不能被改变的变量。

### 初始化和 const

- `const`对象**必须初始化**，且**不能被改变**。
- `const`变量默认仅在文件内有效，不能被其他文件访问，不同文件中的同名`const`变量各自独立。
- 若想在多个文件中共享`const`对象，必须在定义之前添加`extern`关键字。`const`变量声明、定义都添加`extern`关键字，只需要定义一次就可以实现共享。

### const 的引用

- **对常量的引用**（reference to const）：指向 `const` 对象的引用，如 `const int ival=1; const int &refVal = ival;`，可以读取但不能修改 `refVal`。
- **临时量**（temporary）对象：当编译器需要一个空间来暂存表达式的求值结果时，临时创建的一个未命名的对象。
- 对临时量的引用是非法行为。

### 指针和 const

- **指向常量的指针**（pointer to const）：不能改变其所指对象的值，如 `const double pi = 3.14; const double *cptr = &pi;`。
- **const pointer**：指针本身是常量，也就是说指针固定指向该对象，存放在指针中的地址不变，地址所对应的那个对象值可以修改，如`int i = 0; int *const ptr = &i;`

- `const`默认作用于其左边的东西，否则作用于其右边的东西。

> Const applies to the thing left of it. If there is nothing on the left then it applies to the thing right of it.

### 顶层 const

- 顶层`const`（top-level const）：指针本身是常量。
- 底层`const`（low-level const）：指针指向的对象是常量。拷贝时严格要求相同的底层`const`资格。

- `const`在`*`的左边，值不能修改，底层 const。`const`在`*`的右边，地址不能修改，顶层 const。

### constexpr 和常量表达式

- 常量表达式：指值不会改变，且在编译过程中就能得到计算结果的表达式。
- `C++11`规定，允许将变量声明为`constexpr`类型以便由编译器来**验证**变量的值是否是一个常量的表达式。
- 若在`constexpr`声明中定义了一个指针，限定符`constexpr`仅对指针有效，与指针所指的对象无关。

```cpp
const int *p = nullptr;      //p 是指向整型常量的指针
constexpr int *q = nullptr;  //q 是指向整数的常量指针
```

## 处理类型

### 类型别名

- ~~传统别名：使用**typedef**来定义类型的同义词。`typedef double wages;`~~
- `C++11`新标准别名：**别名声明（alias declaration）**：`using SI = Sales_item;`

```cpp
// 对于复合类型（指针等）不能代回原式来进行理解
typedef char *pstring;  // pstring 是 char* 的别名
const pstring cstr = 0; // 指向 char 的常量指针
// 如改写为 const char *cstr = 0;不正确，为指向 const char 的指针

// 辅助理解（可代回后加括号）
// const pstring cstr = 0;代回后 const (char *) cstr = 0;
// const char *cstr = 0;即为 (const char *) cstr = 0;
```

### auto 类型说明符 #TODO

- **auto**类型说明符：让编译器**自动推断类型**。

- 一条声明语句只能有一个数据类型，所以一个`auto`声明多个变量时，该语句中所有变量的初始基本数据类型类型必须相同 (包括复杂类型`&`和`*`)。
  - `auto i = 0, *p = &i;    //正确`
  - `auto sz = 0, pi = 3.14  //错误`
  - `int i = 0, &r = i; auto a = r;` 推断 `a` 的类型是 `int`。

- `auto` 一般会忽略顶层 `const`，同时保留底层 `const`。如果希望推断出的 `auto` 类型是顶层 `const`，需要加 `const`。
  - `const int ci = 1; const auto f = ci; // ci 的推断类型是 int，f 是 const int`

### decltype 类型指示符 #TODO

- 需要从表达式的类型推断出要定义的变量的类型，但不需要使用表达式的值初始化变量。

- **decltype**（Declared Type）：返回操作数的**数据类型**。
  - `decltype(f()) sum = x;` 推断`sum`的类型是函数`f`的返回类型。
  - 不会忽略 `顶层 const`。

- 如果对变量加一层或多层括号，编译器会将其认为是一个表达式，结果将是引用。
  - 如`int i = 42`，则`decltype((i)) e`得到结果为`int &`引用。
  - 赋值是会产生引用的一类典型表达式，引用的类型就是左值的类型。也就是说，如果`i`是`int`，则表达式`i=x`的类型是`int &`。

## 自定义数据结构

### struct

- 尽量不要把类定义和对象定义放在一起，避免混淆。
- 类可以关键字`struct`开始，紧跟类名和类体。
- 类体可定义数据成员与成员函数。
- `C++11`：可以为类数据成员提供一个**类内初始值（in-class initializer）**。

### 编写自己的头文件

- 头文件通常包含哪些只能被定义一次的实体：`class`、`const`和`constexpr`变量。

- 预处理器概述：
  - **预处理器**（preprocessor）：确保头文件多次包含仍能安全工作，当预处理器看到`#include`标记时，会用指定的头文件内容代替`#include`。
  - **头文件保护符**（header guard）：头文件保护符依赖于预处理变量的状态：已定义和未定义。
    - `#indef`已定义时为真
    - `#inndef`未定义时为真
    - 头文件保护符的名称需要唯一，且保持全部大写。养成良好习惯，不论是否该头文件被包含，要加保护符。

```cpp
#ifndef SALES_DATA_H  //SALES_DATA_H 未定义时为真
#define SALES_DATA_H

strct Sale_data{
    ...
}
#endif
```
